UNUSED CODE ARCHIVE
===================

This file contains code that was identified as unused or redundant.
If the application continues to function correctly, these can be safely deleted.

--- BACKEND: backend/services/optimize.py (Standalone simulation script, not used by API) ---

import random
import copy
from matching import calculate_team_cost, evaluate_team
import matplotlib.pyplot as plt
import numpy as np

# ‡∏™‡∏£‡πâ‡∏≤‡∏á Mock Data ‡∏Ç‡∏≠‡∏á‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô (Class ‡πÄ‡∏™‡∏°‡∏∑‡∏≠‡∏ô)
class Person:
    def __init__(self, id, name, o, c, e, a, n, role):
        self.id = id
        self.name = name
        self.ocean_openness = o
        self.ocean_conscientiousness = c
        self.ocean_extraversion = e
        self.ocean_agreeableness = a
        self.ocean_neuroticism = n
        self.role = role # ‡πÄ‡∏ä‡πà‡∏ô 'Dev', 'Designer', 'PM'

    def __repr__(self):
        return f"{self.name} ({self.role}) [O:{self.ocean_openness} C:{self.ocean_conscientiousness} ...]"

class TeamOptimizer:
    def __init__(self, people_pool):
        self.pool = people_pool
    
    def find_best_team(self, required_roles, iterations=5000):
        """
        Monte Carlo Simulation ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏≤‡∏ó‡∏µ‡∏°‡∏ó‡∏µ‡πà Cost ‡∏ï‡πà‡∏≥‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
        required_roles: dict ‡πÄ‡∏ä‡πà‡∏ô {'Dev': 2, 'Designer': 1}
        """
        best_team = None
        min_cost = float('inf')
        
        # ‡πÅ‡∏¢‡∏Å‡∏Ñ‡∏ô‡∏ï‡∏≤‡∏° Role ‡πÉ‡∏™‡πà‡∏ñ‡∏±‡∏á‡πÑ‡∏ß‡πâ
        role_buckets = {}
        for p in self.pool:
            role_buckets.setdefault(p.role, []).append(p)
            
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Ñ‡∏ô‡∏û‡∏≠‡πÑ‡∏´‡∏°
        for role, count in required_roles.items():
            if len(role_buckets.get(role, [])) < count:
                print(f"Error: Not enough people for role {role}")
                return None

        print(f"üîÑ Simulating {iterations} combinations...")
        
        for i in range(iterations):
            current_team = []
            
            # ‡∏™‡∏∏‡πà‡∏°‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏ô‡∏ï‡∏≤‡∏° Role Requirement
            for role, count in required_roles.items():
                selected = random.sample(role_buckets[role], count)
                current_team.extend(selected)
            
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Cost ‡∏î‡πâ‡∏ß‡∏¢ Golden Formula ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì
            cost = calculate_team_cost(current_team)
            
            # ‡πÄ‡∏Å‡πá‡∏ö‡∏ó‡∏µ‡∏°‡∏ó‡∏µ‡πà‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
            if cost < min_cost:
                min_cost = cost
                best_team = current_team
                
        return best_team, min_cost


# ==========================================
#  ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô (Usage Example)
# ==========================================
if __name__ == "__main__":
    # 1. ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô‡∏à‡∏≥‡∏•‡∏≠‡∏á (Pool)
    #    ‡∏™‡∏±‡∏á‡πÄ‡∏Å‡∏ï: ‡∏ú‡∏°‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ñ‡∏ô‡∏´‡∏•‡∏≤‡∏¢‡∏™‡πÑ‡∏ï‡∏•‡πå ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏ß‡πà‡∏≤‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏á
    staff_pool = [
        # Developers (High C, Low E)
        Person(1, "Dev_A", 40, 45, 20, 40, 15, "Dev"), 
        Person(2, "Dev_B", 35, 48, 15, 38, 20, "Dev"),
        Person(3, "Dev_C", 42, 42, 25, 42, 18, "Dev"),
        # Designers (High O, High E)
        Person(4, "Des_X", 48, 30, 45, 40, 25, "Designer"), 
        Person(5, "Des_Y", 50, 35, 40, 45, 22, "Designer"),
        # PMs (High E, High A)
        Person(6, "PM_1", 35, 40, 48, 48, 15, "PM"),   
        Person(7, "PM_2", 30, 45, 45, 42, 20, "PM"),
        # "‡∏ï‡∏±‡∏ß‡∏õ‡πà‡∏ß‡∏ô" (Low A, High N) -> ‡∏£‡∏∞‡∏ö‡∏ö‡πÑ‡∏°‡πà‡∏Ñ‡∏ß‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏ó‡∏≤‡∏á‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏≠‡∏∑‡πà‡∏ô
        Person(8, "Toxic_Guy", 30, 20, 30, 10, 45, "Dev"), 
    ]

    # 2. ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÇ‡∏à‡∏ó‡∏¢‡πå: ‡∏≠‡∏¢‡∏≤‡∏Å‡πÑ‡∏î‡πâ‡∏ó‡∏µ‡∏° Dev 2, Designer 1, PM 1
    requirements = {'Dev': 2, 'Designer': 1, 'PM': 1}
    
    optimizer = TeamOptimizer(staff_pool)
    best_team, best_cost = optimizer.find_best_team(requirements)

    # 3. ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•
    print("\nüèÜ BEST TEAM FOUND:")
    for member in best_team:
        print(f"  - {member.name} ({member.role})")
    
    # ‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô evaluate_team ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏õ‡∏£‡∏∞‡πÄ‡∏°‡∏¥‡∏ô‡∏ú‡∏•
    result = evaluate_team(best_team)
    print(f"\nüìä Evaluation:")
    print(f"   Cost: {result['cost']}")
    print(f"   Score: {result['score']}/100")
    print(f"   Rating: {result['rating']}")

    def plot_team_radar(team, team_score):
    # 1. ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
        labels = ['Openness', 'Conscientiousness', 'Extraversion', 'Agreeableness', 'Neuroticism']
        
        # ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢‡∏Ç‡∏≠‡∏á‡∏ó‡∏µ‡∏°‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏î‡πâ‡∏≤‡∏ô
        stats = np.array([
            np.mean([m.ocean_openness for m in team]),
            np.mean([m.ocean_conscientiousness for m in team]),
            np.mean([m.ocean_extraversion for m in team]),
            np.mean([m.ocean_agreeableness for m in team]),
            np.mean([m.ocean_neuroticism for m in team])
        ])
        
        # ‡∏õ‡∏¥‡∏î‡∏ß‡∏á‡∏Å‡∏£‡∏≤‡∏ü (‡πÉ‡∏´‡πâ‡∏à‡∏∏‡∏î‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏à‡∏∏‡∏î‡πÅ‡∏£‡∏Å)
        stats = np.concatenate((stats, [stats[0]]))
        angles = np.linspace(0, 2 * np.pi, len(labels), endpoint=False).tolist()
        angles += [angles[0]]

        # 2. ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ß‡∏≤‡∏î‡∏Å‡∏£‡∏≤‡∏ü
        fig, ax = plt.subplots(figsize=(6, 6), subplot_kw=dict(polar=True))
        
        # ‡∏ß‡∏≤‡∏î‡πÄ‡∏™‡πâ‡∏ô Grid ‡πÅ‡∏•‡∏∞ Label
        ax.set_theta_offset(np.pi / 2)
        ax.set_theta_direction(-1)
        ax.set_xticks(angles[:-1])
        ax.set_xticklabels(labels, size=10, weight='bold')
        
        # ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÅ‡∏Å‡∏ô Y (0-50 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)
        ax.set_ylim(0, 50)
        ax.set_yticks([10, 20, 30, 40, 50])
        ax.set_yticklabels(["10", "20", "30", "40", "50"], color="grey", size=8)

        # 3. Plot ‡πÄ‡∏™‡πâ‡∏ô‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢‡∏ó‡∏µ‡∏°
        ax.plot(angles, stats, linewidth=2, linestyle='solid', label='Team Average', color='#1f77b4')
        ax.fill(angles, stats, '#1f77b4', alpha=0.25)

        # (Optional) Plot ‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ñ‡∏ô‡∏à‡∏≤‡∏á‡πÜ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏£‡∏∞‡∏à‡∏≤‡∏¢
        for member in team:
            m_stats = [member.ocean_openness, member.ocean_conscientiousness, member.ocean_extraversion, 
                    member.ocean_agreeableness, member.ocean_neuroticism]
            m_stats += [m_stats[0]]
            ax.plot(angles, m_stats, linewidth=1, linestyle='dashed', alpha=0.3, color='grey')

        # Title
        plt.title(f"Team Analysis (Score: {team_score})", size=15, color='#333333', y=1.1)
        plt.legend(loc='upper right', bbox_to_anchor=(1.3, 1.1))
        
        plt.tight_layout()
        plt.show()

    plot_team_radar(best_team, result['score'])

--- BACKEND: backend/services/matching.py ---

# Aliases for backward compatibility (moved to cost_to_score)
def calculate_team_score_from_cost(cost):
    return cost_to_score(cost)

def calculate_team_score(cost):
    return cost_to_score(cost)

--- BACKEND: backend/services/ai.py (generate_team_name) ---

async def generate_team_name(leader, member_names, final_score, team_rating, strategy):
    prompt = ChatPromptTemplate.from_template("""
    Role: You are the "Grand Guild Master" naming a newly formed party.

    **Party Leader:** {leader_name} (Class: {leader_class})
    **Members:** {member_names}
    **Team Score:** {score}% ({rating})
    **Strategy:** {strategy}

    **TASK:** Create an epic Thai team name and explain why this team works well together.

    **OUTPUT RULES:**
    - team_name: Creative Thai name (e.g. "‡∏†‡∏≤‡∏Ñ‡∏µ‡∏û‡∏¥‡∏ó‡∏±‡∏Å‡∏©‡πå‡πÄ‡∏î‡∏î‡πÑ‡∏•‡∏ô‡πå", "‡∏Å‡∏≠‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏•‡πà‡∏≤‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Å‡∏ï‡πå")
    - reason: 2-3 sentences in Thai explaining the team synergy. NO MARKDOWN.

    **JSON OUTPUT:**
    {{
      "team_name": "...",
      "reason": "..."
    }}
    """)

    chain = prompt | llm | StrOutputParser()

--- BACKEND: backend/services/ai.py (Quest Generation Logic) ---

QUEST_GENERATION_PROMPT = """
‡∏Ñ‡∏∏‡∏ì‡∏Ñ‡∏∑‡∏≠ AI ‡∏ó‡∏µ‡πà‡∏ä‡πà‡∏ß‡∏¢‡∏™‡∏£‡πâ‡∏≤‡∏á Quest (‡∏†‡∏≤‡∏£‡∏Å‡∏¥‡∏à) ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏∞‡∏ö‡∏ö HR Gamification

‡∏à‡∏≤‡∏Å prompt ‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ ‡πÉ‡∏´‡πâ‡∏™‡∏£‡πâ‡∏≤‡∏á Quest ‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö JSON ‡∏î‡∏±‡∏á‡∏ô‡∏µ‡πâ:

**Input Prompt:**
{prompt}

**‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤:** {deadline_days} ‡∏ß‡∏±‡∏ô

**Skills ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö (‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏ô‡∏µ‡πâ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô):**
{available_skills}

**‡∏Å‡∏£‡∏∏‡∏ì‡∏≤ Generate JSON:**
```json
{{
  "title": "‡∏ä‡∏∑‡πà‡∏≠ Quest ‡∏ó‡∏µ‡πà‡∏î‡∏∂‡∏á‡∏î‡∏π‡∏î (‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢)",
  "description": "‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢‡πÅ‡∏ö‡∏ö Professional (2-3 ‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ ‡∏ï‡∏£‡∏á‡∏õ‡∏£‡∏∞‡πÄ‡∏î‡πá‡∏ô)",
  "rank": "<‡∏ï‡∏±‡∏î‡∏™‡∏¥‡∏ô‡πÉ‡∏à‡πÄ‡∏≠‡∏á ‡∏ï‡∏≤‡∏° Rank Guidelines ‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á>",
  "team_size": "<‡∏ï‡∏±‡∏î‡∏™‡∏¥‡∏ô‡πÉ‡∏à‡πÄ‡∏≠‡∏á 1-5 ‡∏Ñ‡∏ô>",
  "required_skills": [
    {{"name": "Skill ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ", "level": 3}}
  ],
  "ocean_preference": {{
    "high": ["C"],
    "low": ["N"]
  }}
}}
```

**Rank Guidelines (‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏´‡πâ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏Å‡∏±‡∏ö‡∏á‡∏≤‡∏ô‡πÅ‡∏•‡∏∞ deadline):**
- **S**: deadline ‡∏Å‡∏£‡∏∞‡∏ä‡∏±‡πâ‡∏ô‡∏°‡∏≤‡∏Å (1-2 ‡∏ß‡∏±‡∏ô) ‡∏´‡∏£‡∏∑‡∏≠‡∏á‡∏≤‡∏ô‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏°‡∏≤‡∏Å‡πÜ
- **A**: deadline ‡∏™‡∏±‡πâ‡∏ô (3-5 ‡∏ß‡∏±‡∏ô) ‡∏´‡∏£‡∏∑‡∏≠‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ expert
- **B**: deadline ‡∏õ‡∏Å‡∏ï‡∏¥ (6-10 ‡∏ß‡∏±‡∏ô) ‡∏á‡∏≤‡∏ô‡∏ã‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô‡∏û‡∏≠‡∏™‡∏°‡∏Ñ‡∏ß‡∏£
- **C**: deadline ‡∏¢‡∏∑‡∏î‡∏´‡∏¢‡∏∏‡πà‡∏ô (10-20 ‡∏ß‡∏±‡∏ô) ‡∏á‡∏≤‡∏ô‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ
- **D**: deadline ‡∏¢‡∏≤‡∏ß (20+ ‡∏ß‡∏±‡∏ô) ‡∏´‡∏£‡∏∑‡∏≠‡∏á‡∏≤‡∏ô‡∏á‡πà‡∏≤‡∏¢ beginner friendly

**Team Size Guidelines:**
- ‡∏á‡∏≤‡∏ô‡∏á‡πà‡∏≤‡∏¢‡πÜ 1-2 ‡∏Ñ‡∏ô: ‡∏á‡∏≤‡∏ô‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£, ‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô, ‡∏á‡∏≤‡∏ô D/C
- ‡∏á‡∏≤‡∏ô‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á 2-3 ‡∏Ñ‡∏ô: ‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ‡πÄ‡∏•‡πá‡∏Å, ‡∏á‡∏≤‡∏ô B/C
- ‡∏á‡∏≤‡∏ô‡∏ã‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô 3-5 ‡∏Ñ‡∏ô: ‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ‡πÉ‡∏´‡∏ç‡πà, ‡∏á‡∏≤‡∏ô A/S

**OCEAN Preference:**
- High C: ‡∏á‡∏≤‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î
- High E: ‡∏á‡∏≤‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠‡∏Ñ‡∏ô‡∏°‡∏≤‡∏Å
- Low N: ‡∏á‡∏≤‡∏ô‡∏Å‡∏î‡∏î‡∏±‡∏ô ‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏à‡πÄ‡∏¢‡πá‡∏ô
- High O: ‡∏á‡∏≤‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏¥‡∏î‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏™‡∏£‡∏£‡∏Ñ‡πå
- High A: ‡∏á‡∏≤‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏õ‡∏£‡∏∞‡∏™‡∏≤‡∏ô‡∏á‡∏≤‡∏ô‡∏°‡∏≤‡∏Å

**Important:**
- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å rank ‡∏ï‡∏≤‡∏° deadline_days ‡πÅ‡∏•‡∏∞‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ã‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô‡∏Ç‡∏≠‡∏á‡∏á‡∏≤‡∏ô ‡∏≠‡∏¢‡πà‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å A ‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á
- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Skills ‡∏ó‡∏µ‡πà‡πÄ‡∏™‡∏£‡∏¥‡∏°‡∏Å‡∏±‡∏ô ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏ã‡πâ‡∏≥‡∏Å‡∏±‡∏ô

‡∏ï‡∏≠‡∏ö‡πÄ‡∏õ‡πá‡∏ô JSON ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°
"""

def generate_quest(prompt: str, deadline_days: int = 7) -> dict:
    """Generate quest details from natural language prompt using Gemini"""
    from data.skills import get_all_skills # Lazy import to avoid circular dependency
    ALL_SKILLS = get_all_skills()
    
    # Format available skills as string
    skills_str = ", ".join(ALL_SKILLS[:50])  # Limit to avoid token overflow
    
    # Create the full prompt
    full_prompt = QUEST_GENERATION_PROMPT.format(
        prompt=prompt,
        deadline_days=deadline_days,
        available_skills=skills_str
    )
    
    try:
        response = llm.invoke(full_prompt)
        content = response.content
        
        # Extract JSON from response
        if "```json" in content:
            json_str = content.split("```json")[1].split("```")[0].strip()
        elif "```" in content:
            json_str = content.split("```")[1].split("```")[0].strip()
        else:
            json_str = content.strip()
        
        quest_data = json.loads(json_str)
        
        # Validate and set defaults
        quest_data.setdefault("title", "New Quest")
        quest_data.setdefault("description", prompt)
        quest_data.setdefault("rank", "C")
        quest_data.setdefault("team_size", 3)  # AI recommends this
        quest_data.setdefault("required_skills", [])
        quest_data.setdefault("ocean_preference", {})
        
        # Validate rank
        if quest_data["rank"] not in ["D", "C", "B", "A", "S"]:
            quest_data["rank"] = "C"
        
        return quest_data
        
    except Exception as e:
        print(f"Quest generation error: {e}")
        # Return fallback quest
        return {
            "title": "Custom Quest",
            "description": prompt,
            "rank": "C",
            "required_skills": [],
            "ocean_preference": {},
            "deadline_days": 7
        }

--- FRONTEND: frontend/lib/matching.ts ---

export const formatOceanScore = (score: number) => {
  return Math.round(score * 10) / 10;
};

--- FRONTEND: frontend/app/quests/team/page.tsx ---

const API_URL = process.env.NEXT_PUBLIC_API_URL || "http://localhost:8000";

--- FRONTEND: frontend/components/ProtectedRoute.tsx (Redundant with global AuthGuard) ---

"use client";
import { useAuth } from "@/context/AuthContext";
import { useRouter } from "next/navigation";
import { useEffect } from "react";
import ElementalLoader from "./ElementalLoader";

export default function ProtectedRoute({
  children,
}: {
  children: React.ReactNode;
}) {
  const { user, loading } = useAuth();
  const router = useRouter();

  useEffect(() => {
    if (!loading && !user) {
      router.push("/login");
    }
  }, [user, loading, router]);

  if (loading) {
    return (
      <div className="h-screen flex items-center justify-center">
        <ElementalLoader />
      </div>
    );
  }

  return user ? <>{children}</> : null;
}

--- FRONTEND: frontend/components/ModernSelect.tsx (Entire file, unused) ---

"use client";

import React, { useState, useRef, useEffect } from "react";
import { ChevronDown, Check } from "lucide-react";

interface Option {
  id: string;
  name: string;
  label?: string;
}

interface ModernSelectProps {
  options: Option[];
  value: string;
  onChange: (value: string) => void;
  placeholder?: string;
  className?: string;
}

export default function ModernSelect({
  options,
  value,
  onChange,
  placeholder = "Select an option",
  className = "",
}: ModernSelectProps) {
  const [isOpen, setIsOpen] = useState(false);
  const containerRef = useRef<HTMLDivElement>(null);

  const selectedOption = options.find((opt) => opt.id === value);

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        containerRef.current &&
        !containerRef.current.contains(event.target as Node)
      ) {
        setIsOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  return (
    <div className={`relative ${className}`} ref={containerRef}>
      <button
        type="button"
        onClick={() => setIsOpen(!isOpen)}
        className="w-full flex items-center justify-between px-4 py-2.5 bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-xl text-sm transition-all hover:border-indigo-400 focus:ring-2 focus:ring-indigo-500 outline-none shadow-sm"
      >
        <span className={selectedOption ? "text-slate-800 dark:text-white font-medium" : "text-slate-400"}>
          {selectedOption ? (selectedOption.label || selectedOption.name) : placeholder}
        </span>
        <ChevronDown size={18} className={`text-slate-400 transition-transform ${isOpen ? "rotate-180" : ""}`} />
      </button>

      {isOpen && (
        <div className="absolute z-50 w-full mt-2 bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-xl shadow-xl overflow-hidden animate-in fade-in zoom-in-95 duration-200">
          <div className="max-h-60 overflow-y-auto p-1 custom-scrollbar">
            {options.map((option) => {
              const isActive = option.id === value;
              return (
                <div
                  key={option.id}
                  onClick={() => {
                    onChange(option.id);
                    setIsOpen(false);
                  }}
                  className={`
                    flex items-center justify-between px-3 py-2 rounded-lg cursor-pointer transition-colors
                    ${isActive 
                      ? "bg-indigo-50 dark:bg-indigo-900/30 text-indigo-700 dark:text-indigo-300 font-bold" 
                      : "text-slate-600 dark:text-slate-300 hover:bg-slate-50 dark:hover:bg-slate-700/50"}
                  `}
                >
                  <span>{option.label || option.name}</span>
                  {isActive && <Check size={16} />}
                </div>
              );
            })}
          </div>
        </div>
      )}
    </div>
  );
}
